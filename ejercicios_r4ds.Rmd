---
title: "Parte III"
author: "ronny hdez-mora"
date: "5/25/2019"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
```

# Capítulo 15
## Funciones

##2 Hacer función propia para la varianza
```{r}
secuencia <- c(10, 15, 30, 28, NA, 8)

varianza <- function(x) {
  media <- mean(secuencia, na.rm = TRUE)
  total <- length(secuencia) - 1
  sumatoria <- sum(cuadrado <- (x - media)^2)
  return(sumatoria / total)
}
```

##5 Hacer funcion para tomar dos vectores y

```{r}
secuencia_a <- c(10, 15, 30, 28, NA, 8)
secuencia_b <- c(10, NA, 30, 28, 17, 8)

both_na <- function(x, y) {
  return(paste("La posición de x es:", which(is.na(x)), ", y",
               "la posición de y es:", which(is.na(y))))
}

both_na(secuencia_a, secuencia_b)

```

##6 ¿Qué hacen las siguientes funciones?

```{r}

is_directory <- function(x) file.info(x)$is.dir
is_readable <- function(x) file.access(x, 4) == 0
```

# Functions are for humans and computers

##1 Leer el código de las funciones y hacer nombres 

```{r}
# Tomar en cuenta lo que hace doble o simple & |
a <- c(1:5)
b <- c(1:5)

c <- c(6:10)
d <- c(6:10)

a == b & c == d
a == b && c == d

5 > 4 & 6 > 3
5 > 4 && 6 > 3

5 < 4 & 6 > 3
5 < 4 && 6 > 3

5 < 4 | 6 > 3
5 < 4 || 6 > 3

```


```{r}
a <- function(x, y, op) {
  switch (op,
          plus = x + y,
          minus = x - y,
          times = x * y, 
          divide = x / y,
          stop("Unknown op!")
  )
}
```


# Escribir funcion que diga buenos dias, buenas tardes o
# buenas noches de acuerdo a la hora del dia.

```{r}
saludo <- function(hora = lubridate::now()){
  if (hour(hora) <= 12) {
    print("¡Buenos días!")
  } else if (hour(hora) > 12) {
    print("¡Buenas tardes!")
  } else {
    print("¡Buenas noches!")
  } 
}
```


##3 Escribir funcion que si numero es divisible por 3 imprime 
## fizz, si es divisible por tres y cinco imprime fizzbuzz. Lo
## demas imprime el numero

```{r}
fizzbuzz <- function(x) {
  if(x %% 3 == 0 & x %% 5 == 0) {
    print("fizzbuzz")
  } else if(x %% 3 == 0) {
    print("fizz")
  } else {
    return(x)
  }
}
```

# Una funcion de ejemplo con dot-dot-dot

```{r}
comas <- function(...) {
  stringr::str_c(..., collapse = ",")
}

comas(letters[1:5])
```

# Capítulo 17

Uno de los primeros ejemplos de loops:
```{r}
df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

output <- vector("double", ncol(df))

for (i in seq_along(df)) {
  output[[i]] <- median(df[[i]])
}
```

## Ejercicios

 - 1 Generar loops para: 
  
### 1.a Obtener media de cada columna en mtcars
```{r}
# Estructura para almacenar valores
medias <- vector("double", ncol(mtcars))

# Loop
for (i in seq_along(mtcars)) {
  medias[[i]] <- mean(mtcars[[i]])
}

# Mostrar resultados
print(medias)
```

### 1.b Determinar el tipo de cada columna en `fligths13::fligths`
```{r}
# Crear objeto con datos
vuelos <- nycflights13::flights

# Estructura para almancenar datos
# tipo_columnas <- vector("character", ncol(vuelos))

# Hay que hacer estructura de lista porque clase de columna
# time_hour tiene dos: "POSIXct" "POSIXt" y eso causa problemas
# de espacio en la estructura de vector
tipo_columnas <- list()

# Loop
for (i in seq_along(vuelos)) {
  tipo_columnas[[i]] <- class(vuelos[[i]])
}

# Mostrar resultados
tipo_columnas
```

### 1.c Computar el número de valores únicos en cada columna de iris
```{r}
# Estructura para almacenar datos
valores_unicos <- vector("double", ncol(iris))

# Loop
for (i in seq_along(iris)) {
  valores_unicos[[i]] <- length(unique(iris[[i]]))
}

# Mostrar resultados
valores_unicos
```

 - 4. Es común observar loops que no pre-alocan el output y en lugar, 
 incrementan el tamaño del vector en cada paso. ¿Cómo esto afecta el
 rendimiento? Diseñe y ejecute un experimento
 
```{r}
output <- vector("integer", 0)

for (i in seq_along(x)) {
  output <- c(output, lengths(x[[i]]))
}

output
```
 
